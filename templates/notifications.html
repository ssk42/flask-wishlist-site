{% extends 'base.html' %}

{% block title %}Notifications Â· Wishlist App{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-lg-8">
        <h1 class="h3 mb-4">Notifications</h1>

        {% if notifications %}
        <div class="list-group shadow-sm">
            {% for notif in notifications %}
            <a href="{{ notif.link }}"
                class="list-group-item list-group-item-action d-flex align-items-center justify-content-between p-3 {{ 'bg-light' if not notif.is_read else '' }}"
                onclick="markRead({{ notif.id }}, event)">
                <div>
                    <p class="mb-1 text-dark">{{ notif.message }}</p>
                    <small class="text-muted">{{ notif.created_at.strftime('%b %d, %H:%M') }}</small>
                </div>
                {% if not notif.is_read %}
                <span class="badge bg-primary rounded-pill ms-2" title="Unread">â€¢</span>
                {% endif %}
            </a>
            {% endfor %}
        </div>
        {% else %}
        <div class="text-center py-5 text-muted">
            <div class="fs-1 mb-2">ðŸ”•</div>
            <p>No notifications yet.</p>
        </div>
        {% endif %}
    </div>
</div>

<script>
    async function markRead(notifId, event) {
        // Determine if we should stop navigation (if clicking a specific mark-read button, which we don't have here, we click the whole row)
        // Actually, we want to Fire-and-Forget the read status, then let the browser navigate
        const markReadUrl = "{{ url_for('social.mark_notification_read', notif_id=0) }}".slice(0, -1) + notifId;
        try {
            navigator.sendBeacon(markReadUrl);
        } catch (e) {
            // Fallback for older browsers
            fetch(markReadUrl, {
                method: 'POST',
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });
        }
    }
</script>
{% endblock %}